// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: seller.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const haveTagName = `-- name: HaveTagName :one
SELECT EXISTS (
        SELECT 1
        FROM "tag" t
            LEFT JOIN "shop" s ON "shop_id" = s.id
        WHERE s."seller_name" = $1
            AND t."name" = $2
    )
`

type HaveTagNameParams struct {
	SellerName string `json:"seller_name" param:"seller_name"`
	Name       string `json:"name"`
}

func (q *Queries) HaveTagName(ctx context.Context, arg HaveTagNameParams) (bool, error) {
	row := q.db.QueryRow(ctx, haveTagName, arg.SellerName, arg.Name)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const sellerBestSellProduct = `-- name: SellerBestSellProduct :many
SELECT order_detail.product_id,
    product_archive.name,
    product_archive.price,
    product_archive.image_id AS "image_url",
    SUM(order_detail.quantity) AS total_quantity,
    SUM(order_detail.quantity * product_archive.price)::decimal(10, 2) AS total_sell,
    COUNT(order_history.id) AS order_count
FROM "order_detail"
    LEFT JOIN product_archive ON order_detail.product_id = product_archive.id
    AND order_detail.product_version = product_archive.version
    LEFT JOIN order_history ON order_history.id = order_detail.order_id
    LEFT JOIN shop ON order_history.shop_id = shop.id
WHERE shop.seller_name = $1
    AND order_history."created_at" > $3
    AND order_history."created_at" < $3 + INTERVAL '1 month'
GROUP BY product_archive.id,
    product_archive.description,
    product_archive.name,
    product_archive.price,
    product_archive.image_id,
    order_detail.product_id
ORDER BY total_quantity DESC
LIMIT $2
`

type SellerBestSellProductParams struct {
	SellerName string             `json:"seller_name" param:"seller_name"`
	Limit      int64              `json:"limit"`
	Time       pgtype.Timestamptz `json:"time" swaggertype:"string"`
}

type SellerBestSellProductRow struct {
	ProductID     int32          `json:"product_id"`
	Name          string         `json:"name"`
	Price         pgtype.Numeric `json:"price" swaggertype:"number"`
	ImageUrl      string         `json:"image_url"`
	TotalQuantity int64          `json:"total_quantity"`
	TotalSell     pgtype.Numeric `json:"total_sell"`
	OrderCount    int64          `json:"order_count"`
}

func (q *Queries) SellerBestSellProduct(ctx context.Context, arg SellerBestSellProductParams) ([]SellerBestSellProductRow, error) {
	rows, err := q.db.Query(ctx, sellerBestSellProduct, arg.SellerName, arg.Limit, arg.Time)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SellerBestSellProductRow{}
	for rows.Next() {
		var i SellerBestSellProductRow
		if err := rows.Scan(
			&i.ProductID,
			&i.Name,
			&i.Price,
			&i.ImageUrl,
			&i.TotalQuantity,
			&i.TotalSell,
			&i.OrderCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sellerCheckTags = `-- name: SellerCheckTags :one
SELECT NOT EXISTS (
        SELECT 1
        FROM unnest($2::INT []) t
            LEFT JOIN "tag" ON t = "tag"."id"
            LEFT JOIN "shop" s ON "tag"."shop_id" = s."id"
        WHERE "tag"."id" IS NULL
            OR s."seller_name" != $1
    )
`

type SellerCheckTagsParams struct {
	SellerName string  `json:"seller_name" param:"seller_name"`
	Tags       []int32 `json:"tags"`
}

func (q *Queries) SellerCheckTags(ctx context.Context, arg SellerCheckTagsParams) (bool, error) {
	row := q.db.QueryRow(ctx, sellerCheckTags, arg.SellerName, arg.Tags)
	var not_exists bool
	err := row.Scan(&not_exists)
	return not_exists, err
}

const sellerDeleteCoupon = `-- name: SellerDeleteCoupon :execrows
DELETE FROM "coupon" c
WHERE c."id" = $2
    AND "shop_id" =(
        SELECT s."id"
        FROM "shop" s
        WHERE s."seller_name" = $1
            AND s."enabled" = TRUE
    )
`

type SellerDeleteCouponParams struct {
	SellerName string `json:"seller_name" param:"seller_name"`
	ID         int32  `json:"id" param:"id"`
}

func (q *Queries) SellerDeleteCoupon(ctx context.Context, arg SellerDeleteCouponParams) (int64, error) {
	result, err := q.db.Exec(ctx, sellerDeleteCoupon, arg.SellerName, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const sellerDeleteCouponTag = `-- name: SellerDeleteCouponTag :execrows
DELETE FROM "coupon_tag" tp
WHERE EXISTS (
        SELECT 1
        FROM "coupon" c
            JOIN "shop" s ON s."id" = c."shop_id"
        WHERE s."seller_name" = $1
            AND s."enabled" = TRUE
            AND c."id" = $3
    )
    AND "coupon_id" = $3
    AND "tag_id" = $2
`

type SellerDeleteCouponTagParams struct {
	SellerName string `json:"seller_name" param:"seller_name"`
	TagID      int32  `json:"tag_id"`
	ID         int32  `json:"id" param:"id"`
}

func (q *Queries) SellerDeleteCouponTag(ctx context.Context, arg SellerDeleteCouponTagParams) (int64, error) {
	result, err := q.db.Exec(ctx, sellerDeleteCouponTag, arg.SellerName, arg.TagID, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const sellerDeleteProduct = `-- name: SellerDeleteProduct :execrows
DELETE FROM "product" p
WHERE "shop_id" =(
        SELECT s."id"
        FROM "shop" s
        WHERE s."seller_name" = $1
            AND s."enabled" = TRUE
    )
    AND p."id" = $2
`

type SellerDeleteProductParams struct {
	SellerName string `json:"seller_name" param:"seller_name"`
	ID         int32  `json:"id" param:"id"`
}

func (q *Queries) SellerDeleteProduct(ctx context.Context, arg SellerDeleteProductParams) (int64, error) {
	result, err := q.db.Exec(ctx, sellerDeleteProduct, arg.SellerName, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const sellerDeleteProductTag = `-- name: SellerDeleteProductTag :execrows
DELETE FROM "product_tag" tp
WHERE EXISTS (
        SELECT 1
        FROM "product" p
            JOIN "shop" s ON s."id" = p."shop_id"
        WHERE s."seller_name" = $1
            AND p."id" = $3
            AND s."enabled" = TRUE
    )
    AND "product_id" = $3
    AND "tag_id" = $2
`

type SellerDeleteProductTagParams struct {
	SellerName string `json:"seller_name" param:"seller_name"`
	TagID      int32  `json:"tag_id"`
	ID         int32  `json:"id" param:"id"`
}

func (q *Queries) SellerDeleteProductTag(ctx context.Context, arg SellerDeleteProductTagParams) (int64, error) {
	result, err := q.db.Exec(ctx, sellerDeleteProductTag, arg.SellerName, arg.TagID, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const sellerGetCoupon = `-- name: SellerGetCoupon :many
SELECT c."id",
    c."type",
    c."scope",
    c."name",
    c."description",
    c."discount",
    c."start_date",
    c."expire_date"
FROM "coupon" c
    JOIN "shop" s ON c."shop_id" = s.id
WHERE s.seller_name = $1
ORDER BY "start_date" DESC
LIMIT $2 OFFSET $3
`

type SellerGetCouponParams struct {
	SellerName string `json:"seller_name" param:"seller_name"`
	Limit      int64  `json:"limit"`
	Offset     int64  `json:"offset"`
}

type SellerGetCouponRow struct {
	ID          int32              `json:"id" param:"id"`
	Type        CouponType         `json:"type"`
	Scope       CouponScope        `json:"scope"`
	Name        string             `json:"name"`
	Description string             `json:"description"`
	Discount    pgtype.Numeric     `json:"discount" swaggertype:"number"`
	StartDate   pgtype.Timestamptz `json:"start_date" swaggertype:"string"`
	ExpireDate  pgtype.Timestamptz `json:"expire_date" swaggertype:"string"`
}

func (q *Queries) SellerGetCoupon(ctx context.Context, arg SellerGetCouponParams) ([]SellerGetCouponRow, error) {
	rows, err := q.db.Query(ctx, sellerGetCoupon, arg.SellerName, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SellerGetCouponRow{}
	for rows.Next() {
		var i SellerGetCouponRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Scope,
			&i.Name,
			&i.Description,
			&i.Discount,
			&i.StartDate,
			&i.ExpireDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sellerGetCouponDetail = `-- name: SellerGetCouponDetail :one
SELECT c."type",
    c."scope",
    c."name",
    c."discount",
    c."description",
    c."start_date",
    c."expire_date"
FROM "coupon" c
    JOIN "shop" s ON c."shop_id" = s.id
WHERE s."seller_name" = $1
    AND c."id" = $2
`

type SellerGetCouponDetailParams struct {
	SellerName string `json:"seller_name" param:"seller_name"`
	ID         int32  `json:"id" param:"id"`
}

type SellerGetCouponDetailRow struct {
	Type        CouponType         `json:"type"`
	Scope       CouponScope        `json:"scope"`
	Name        string             `json:"name"`
	Discount    pgtype.Numeric     `json:"discount" swaggertype:"number"`
	Description string             `json:"description"`
	StartDate   pgtype.Timestamptz `json:"start_date" swaggertype:"string"`
	ExpireDate  pgtype.Timestamptz `json:"expire_date" swaggertype:"string"`
}

func (q *Queries) SellerGetCouponDetail(ctx context.Context, arg SellerGetCouponDetailParams) (SellerGetCouponDetailRow, error) {
	row := q.db.QueryRow(ctx, sellerGetCouponDetail, arg.SellerName, arg.ID)
	var i SellerGetCouponDetailRow
	err := row.Scan(
		&i.Type,
		&i.Scope,
		&i.Name,
		&i.Discount,
		&i.Description,
		&i.StartDate,
		&i.ExpireDate,
	)
	return i, err
}

const sellerGetCouponTag = `-- name: SellerGetCouponTag :many
SELECT ct."tag_id",
    t."name"
FROM "coupon_tag" ct
    JOIN "coupon" c ON c."id" = ct."coupon_id"
    JOIN "shop" s ON s."id" = c."shop_id"
    JOIN "tag" t ON t."id" = ct."tag_id"
WHERE s."seller_name" = $1
    AND "coupon_id" = $2
`

type SellerGetCouponTagParams struct {
	SellerName string `json:"seller_name" param:"seller_name"`
	CouponID   int32  `json:"coupon_id" param:"id"`
}

type SellerGetCouponTagRow struct {
	TagID int32  `json:"tag_id"`
	Name  string `json:"name"`
}

func (q *Queries) SellerGetCouponTag(ctx context.Context, arg SellerGetCouponTagParams) ([]SellerGetCouponTagRow, error) {
	rows, err := q.db.Query(ctx, sellerGetCouponTag, arg.SellerName, arg.CouponID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SellerGetCouponTagRow{}
	for rows.Next() {
		var i SellerGetCouponTagRow
		if err := rows.Scan(&i.TagID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sellerGetInfo = `-- name: SellerGetInfo :one
SELECT "name",
    "image_id" AS "image_url",
    "description",
    "enabled"
FROM "shop"
WHERE "seller_name" = $1
`

type SellerGetInfoRow struct {
	Name        string `form:"name" json:"name"`
	ImageUrl    string `json:"image_url" swaggertype:"string"`
	Description string `form:"description" json:"description"`
	Enabled     bool   `form:"enabled" json:"enabled"`
}

func (q *Queries) SellerGetInfo(ctx context.Context, sellerName string) (SellerGetInfoRow, error) {
	row := q.db.QueryRow(ctx, sellerGetInfo, sellerName)
	var i SellerGetInfoRow
	err := row.Scan(
		&i.Name,
		&i.ImageUrl,
		&i.Description,
		&i.Enabled,
	)
	return i, err
}

const sellerGetOrder = `-- name: SellerGetOrder :many
SELECT oh."id",
    op."product_name",
    op."thumbnail_url",
    u."name" AS "user_name",
    u."image_id" AS "user_image_url",
    oh."shipment",
    oh."total_price",
    oh."status",
    oh."created_at"
FROM "order_history" AS oh
    INNER JOIN "shop" AS s ON oh."shop_id" = s."id"
    INNER JOIN "user" AS u ON oh."user_id" = u."id"
    LEFT JOIN (
        SELECT od."order_id",
            pa."name" AS "product_name",
            pa."image_id" AS "thumbnail_url",
            ROW_NUMBER() OVER (
                PARTITION BY od."order_id"
                ORDER BY pa."price" DESC
            ) AS rn
        FROM "order_detail" AS od
            INNER JOIN "product_archive" AS pa ON od."product_id" = pa."id"
            AND od."product_version" = pa."version"
        ORDER BY pa."price" DESC
    ) AS op ON oh."id" = op."order_id"
    AND op.rn = 1
WHERE s."seller_name" = $1
ORDER BY "created_at" DESC
LIMIT $2 OFFSET $3
`

type SellerGetOrderParams struct {
	SellerName string `json:"seller_name" param:"seller_name"`
	Limit      int64  `json:"limit"`
	Offset     int64  `json:"offset"`
}

type SellerGetOrderRow struct {
	ID           int32              `json:"id" param:"id"`
	ProductName  string             `json:"product_name"`
	ThumbnailUrl string             `json:"thumbnail_url"`
	UserName     string             `form:"name" json:"user_name"`
	UserImageUrl string             `json:"user_image_url" swaggertype:"string"`
	Shipment     int32              `json:"shipment"`
	TotalPrice   int32              `json:"total_price"`
	Status       OrderStatus        `json:"status"`
	CreatedAt    pgtype.Timestamptz `json:"created_at" swaggertype:"string"`
}

func (q *Queries) SellerGetOrder(ctx context.Context, arg SellerGetOrderParams) ([]SellerGetOrderRow, error) {
	rows, err := q.db.Query(ctx, sellerGetOrder, arg.SellerName, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SellerGetOrderRow{}
	for rows.Next() {
		var i SellerGetOrderRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductName,
			&i.ThumbnailUrl,
			&i.UserName,
			&i.UserImageUrl,
			&i.Shipment,
			&i.TotalPrice,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sellerGetOrderDetail = `-- name: SellerGetOrderDetail :many
SELECT product_archive."id",
    product_archive."name",
    product_archive."description",
    product_archive."price",
    product_archive."image_id" AS "image_url",
    order_detail.quantity
FROM "order_detail"
    LEFT JOIN product_archive ON order_detail.product_id = product_archive.id
    AND order_detail.product_version = product_archive.version
    LEFT JOIN order_history ON order_history.id = order_detail.order_id
    LEFT JOIN shop ON order_history.shop_id = shop.id
WHERE shop.seller_name = $1
    AND order_detail.order_id = $2
ORDER BY quantity * price DESC
`

type SellerGetOrderDetailParams struct {
	SellerName string `json:"seller_name" param:"seller_name"`
	OrderID    int32  `json:"order_id" param:"id"`
}

type SellerGetOrderDetailRow struct {
	ID          pgtype.Int4    `json:"id"`
	Name        string         `json:"name"`
	Description string         `json:"description"`
	Price       pgtype.Numeric `json:"price" swaggertype:"number"`
	ImageUrl    string         `json:"image_url"`
	Quantity    int32          `json:"quantity"`
}

func (q *Queries) SellerGetOrderDetail(ctx context.Context, arg SellerGetOrderDetailParams) ([]SellerGetOrderDetailRow, error) {
	rows, err := q.db.Query(ctx, sellerGetOrderDetail, arg.SellerName, arg.OrderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SellerGetOrderDetailRow{}
	for rows.Next() {
		var i SellerGetOrderDetailRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.ImageUrl,
			&i.Quantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sellerGetOrderHistory = `-- name: SellerGetOrderHistory :one
SELECT "order_history"."id",
    "order_history"."shipment",
    "order_history"."total_price",
    "order_history"."status",
    "order_history"."created_at",
    "user"."id" AS "user_id",
    "user"."name" AS "user_name",
    "user"."image_id" AS "user_image_url"
FROM "order_history"
    JOIN shop ON "order_history".shop_id = shop.id
    JOIN "user" ON "order_history".user_id = "user"."id"
WHERE shop.seller_name = $1
    AND "order_history".id = $2
`

type SellerGetOrderHistoryParams struct {
	SellerName string `json:"seller_name" param:"seller_name"`
	ID         int32  `json:"id" param:"id"`
}

type SellerGetOrderHistoryRow struct {
	ID           int32              `json:"id" param:"id"`
	Shipment     int32              `json:"shipment"`
	TotalPrice   int32              `json:"total_price"`
	Status       OrderStatus        `json:"status"`
	CreatedAt    pgtype.Timestamptz `json:"created_at" swaggertype:"string"`
	UserID       int32              `json:"user_id" param:"id"`
	UserName     string             `form:"name" json:"user_name"`
	UserImageUrl string             `json:"user_image_url" swaggertype:"string"`
}

func (q *Queries) SellerGetOrderHistory(ctx context.Context, arg SellerGetOrderHistoryParams) (SellerGetOrderHistoryRow, error) {
	row := q.db.QueryRow(ctx, sellerGetOrderHistory, arg.SellerName, arg.ID)
	var i SellerGetOrderHistoryRow
	err := row.Scan(
		&i.ID,
		&i.Shipment,
		&i.TotalPrice,
		&i.Status,
		&i.CreatedAt,
		&i.UserID,
		&i.UserName,
		&i.UserImageUrl,
	)
	return i, err
}

const sellerGetProductDetail = `-- name: SellerGetProductDetail :one
SELECT p."name",
    p."description",
    p."image_id" as "image_url",
    p."price",
    p."sales",
    p."stock",
    p."enabled"
FROM "product" p
    JOIN "shop" s ON p."shop_id" = s.id
WHERE s.seller_name = $1
    AND p."id" = $2
`

type SellerGetProductDetailParams struct {
	SellerName string `json:"seller_name" param:"seller_name"`
	ID         int32  `json:"id" param:"id"`
}

type SellerGetProductDetailRow struct {
	Name        string         `form:"name" json:"name"`
	Description string         `form:"description" json:"description"`
	ImageUrl    string         `json:"image_url"`
	Price       pgtype.Numeric `json:"price" swaggertype:"number"`
	Sales       int32          `json:"sales"`
	Stock       int32          `form:"stock" json:"stock"`
	Enabled     bool           `form:"enabled" json:"enabled"`
}

func (q *Queries) SellerGetProductDetail(ctx context.Context, arg SellerGetProductDetailParams) (SellerGetProductDetailRow, error) {
	row := q.db.QueryRow(ctx, sellerGetProductDetail, arg.SellerName, arg.ID)
	var i SellerGetProductDetailRow
	err := row.Scan(
		&i.Name,
		&i.Description,
		&i.ImageUrl,
		&i.Price,
		&i.Sales,
		&i.Stock,
		&i.Enabled,
	)
	return i, err
}

const sellerGetProductTag = `-- name: SellerGetProductTag :many
SELECT pt."tag_id",
    t."name"
FROM "product_tag" pt
    JOIN "product" p ON p."id" = pt."product_id"
    JOIN "shop" s ON s."id" = p."shop_id"
    JOIN "tag" t ON t."id" = pt."tag_id"
WHERE s."seller_name" = $1
    AND "product_id" = $2
    AND s."enabled" = TRUE
`

type SellerGetProductTagParams struct {
	SellerName string `json:"seller_name" param:"seller_name"`
	ProductID  int32  `json:"product_id" param:"id"`
}

type SellerGetProductTagRow struct {
	TagID int32  `json:"tag_id"`
	Name  string `json:"name"`
}

func (q *Queries) SellerGetProductTag(ctx context.Context, arg SellerGetProductTagParams) ([]SellerGetProductTagRow, error) {
	rows, err := q.db.Query(ctx, sellerGetProductTag, arg.SellerName, arg.ProductID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SellerGetProductTagRow{}
	for rows.Next() {
		var i SellerGetProductTagRow
		if err := rows.Scan(&i.TagID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sellerInsertCoupon = `-- name: SellerInsertCoupon :one
INSERT INTO "coupon"(
        "type",
        "scope",
        "shop_id",
        "name",
        "description",
        "discount",
        "start_date",
        "expire_date"
    )
VALUES (
        $2,
        'shop',
        (
            SELECT s."id"
            FROM "shop" s
            WHERE s."seller_name" = $1
                AND s."enabled" = TRUE
        ),
        $3,
        $4,
        $5,
        $6,
        $7
    )
RETURNING "id",
    "type",
    "scope",
    "name",
    "discount",
    "description",
    "start_date",
    "expire_date"
`

type SellerInsertCouponParams struct {
	SellerName  string             `json:"seller_name" param:"seller_name"`
	Type        CouponType         `json:"type"`
	Name        string             `json:"name"`
	Description string             `json:"description"`
	Discount    pgtype.Numeric     `json:"discount" swaggertype:"number"`
	StartDate   pgtype.Timestamptz `json:"start_date" swaggertype:"string"`
	ExpireDate  pgtype.Timestamptz `json:"expire_date" swaggertype:"string"`
}

type SellerInsertCouponRow struct {
	ID          int32              `json:"id" param:"id"`
	Type        CouponType         `json:"type"`
	Scope       CouponScope        `json:"scope"`
	Name        string             `json:"name"`
	Discount    pgtype.Numeric     `json:"discount" swaggertype:"number"`
	Description string             `json:"description"`
	StartDate   pgtype.Timestamptz `json:"start_date" swaggertype:"string"`
	ExpireDate  pgtype.Timestamptz `json:"expire_date" swaggertype:"string"`
}

func (q *Queries) SellerInsertCoupon(ctx context.Context, arg SellerInsertCouponParams) (SellerInsertCouponRow, error) {
	row := q.db.QueryRow(ctx, sellerInsertCoupon,
		arg.SellerName,
		arg.Type,
		arg.Name,
		arg.Description,
		arg.Discount,
		arg.StartDate,
		arg.ExpireDate,
	)
	var i SellerInsertCouponRow
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Scope,
		&i.Name,
		&i.Discount,
		&i.Description,
		&i.StartDate,
		&i.ExpireDate,
	)
	return i, err
}

const sellerInsertCouponTag = `-- name: SellerInsertCouponTag :one
INSERT INTO "coupon_tag"("tag_id", "coupon_id")
SELECT $2,
    $3
WHERE EXISTS (
        SELECT 1
        FROM "tag" t
            JOIN "shop" s ON s."id" = t."shop_id"
        WHERE s."seller_name" = $1
            AND s."enabled" = TRUE
            AND t."id" = $2
    )
    AND EXISTS (
        SELECT 1
        FROM "coupon" c
            JOIN "shop" s ON s."id" = c."shop_id"
        WHERE s."seller_name" = $1
            AND s."enabled" = TRUE
            AND c."id" = $3
    )
RETURNING coupon_id, tag_id
`

type SellerInsertCouponTagParams struct {
	SellerName string `json:"seller_name" param:"seller_name"`
	TagID      int32  `json:"tag_id"`
	CouponID   int32  `json:"coupon_id" param:"id"`
}

func (q *Queries) SellerInsertCouponTag(ctx context.Context, arg SellerInsertCouponTagParams) (CouponTag, error) {
	row := q.db.QueryRow(ctx, sellerInsertCouponTag, arg.SellerName, arg.TagID, arg.CouponID)
	var i CouponTag
	err := row.Scan(&i.CouponID, &i.TagID)
	return i, err
}

const sellerInsertCouponTags = `-- name: SellerInsertCouponTags :exec
INSERT INTO "coupon_tag"("coupon_id", "tag_id")
VALUES ($1, unnest($2::INT []))
`

type SellerInsertCouponTagsParams struct {
	CouponID int32   `json:"coupon_id" param:"id"`
	Tags     []int32 `json:"tags"`
}

func (q *Queries) SellerInsertCouponTags(ctx context.Context, arg SellerInsertCouponTagsParams) error {
	_, err := q.db.Exec(ctx, sellerInsertCouponTags, arg.CouponID, arg.Tags)
	return err
}

const sellerInsertProduct = `-- name: SellerInsertProduct :one
INSERT INTO "product"(
        "version",
        "shop_id",
        "name",
        "description",
        "price",
        "image_id",
        "expire_date",
        "edit_date",
        "stock",
        "enabled"
    )
VALUES (
        1,
        (
            SELECT s."id"
            FROM "shop" s
            WHERE s."seller_name" = $1
                AND s."enabled" = TRUE
        ),
        $2,
        $3,
        $4,
        $5,
        $6,
        NOW(),
        $7,
        $8
    )
RETURNING "id",
    "name",
    "description",
    "price",
    "image_id" AS "image_url",
    "expire_date",
    "edit_date",
    "stock",
    "sales",
    "enabled"
`

type SellerInsertProductParams struct {
	SellerName  string             `json:"seller_name" param:"seller_name"`
	Name        string             `form:"name" json:"name"`
	Description string             `form:"description" json:"description"`
	Price       pgtype.Numeric     `json:"price" swaggertype:"number"`
	ImageID     string             `json:"image_id"`
	ExpireDate  pgtype.Timestamptz `json:"expire_date" swaggertype:"string"`
	Stock       int32              `form:"stock" json:"stock"`
	Enabled     bool               `form:"enabled" json:"enabled"`
}

type SellerInsertProductRow struct {
	ID          int32              `json:"id" param:"id"`
	Name        string             `form:"name" json:"name"`
	Description string             `form:"description" json:"description"`
	Price       pgtype.Numeric     `json:"price" swaggertype:"number"`
	ImageUrl    string             `json:"image_url"`
	ExpireDate  pgtype.Timestamptz `json:"expire_date" swaggertype:"string"`
	EditDate    pgtype.Timestamptz `json:"edit_date" swaggertype:"string"`
	Stock       int32              `form:"stock" json:"stock"`
	Sales       int32              `json:"sales"`
	Enabled     bool               `form:"enabled" json:"enabled"`
}

func (q *Queries) SellerInsertProduct(ctx context.Context, arg SellerInsertProductParams) (SellerInsertProductRow, error) {
	row := q.db.QueryRow(ctx, sellerInsertProduct,
		arg.SellerName,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.ImageID,
		arg.ExpireDate,
		arg.Stock,
		arg.Enabled,
	)
	var i SellerInsertProductRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.ImageUrl,
		&i.ExpireDate,
		&i.EditDate,
		&i.Stock,
		&i.Sales,
		&i.Enabled,
	)
	return i, err
}

const sellerInsertProductTag = `-- name: SellerInsertProductTag :one
INSERT INTO "product_tag"("tag_id", "product_id")
SELECT $2,
    $3
WHERE EXISTS (
        SELECT 1
        FROM "tag" t
            JOIN "shop" s ON s."id" = t."shop_id"
        WHERE s."seller_name" = $1
            AND t."id" = $2
            AND s."enabled" = TRUE
    )
    AND EXISTS (
        SELECT 1
        FROM "product" p
            JOIN "shop" s ON s."id" = p."shop_id"
        WHERE s."seller_name" = $1
            AND p."id" = $3
    )
RETURNING tag_id, product_id
`

type SellerInsertProductTagParams struct {
	SellerName string `json:"seller_name" param:"seller_name"`
	TagID      int32  `json:"tag_id"`
	ProductID  int32  `json:"product_id" param:"id"`
}

func (q *Queries) SellerInsertProductTag(ctx context.Context, arg SellerInsertProductTagParams) (ProductTag, error) {
	row := q.db.QueryRow(ctx, sellerInsertProductTag, arg.SellerName, arg.TagID, arg.ProductID)
	var i ProductTag
	err := row.Scan(&i.TagID, &i.ProductID)
	return i, err
}

const sellerInsertProductTags = `-- name: SellerInsertProductTags :exec
INSERT INTO "product_tag"("product_id", "tag_id")
VALUES ($1, unnest($2::INT []))
`

type SellerInsertProductTagsParams struct {
	ProductID int32   `json:"product_id" param:"id"`
	Tags      []int32 `json:"tags"`
}

func (q *Queries) SellerInsertProductTags(ctx context.Context, arg SellerInsertProductTagsParams) error {
	_, err := q.db.Exec(ctx, sellerInsertProductTags, arg.ProductID, arg.Tags)
	return err
}

const sellerInsertTag = `-- name: SellerInsertTag :one
INSERT INTO "tag"("shop_id", "name")
VALUES (
        (
            SELECT s."id"
            FROM "shop" s
            WHERE s."seller_name" = $1
                AND s."enabled" = TRUE
        ),
        $2
    )
RETURNING "id",
    "name"
`

type SellerInsertTagParams struct {
	SellerName string `json:"seller_name" param:"seller_name"`
	Name       string `json:"name"`
}

type SellerInsertTagRow struct {
	ID   int32  `json:"id"`
	Name string `json:"name"`
}

func (q *Queries) SellerInsertTag(ctx context.Context, arg SellerInsertTagParams) (SellerInsertTagRow, error) {
	row := q.db.QueryRow(ctx, sellerInsertTag, arg.SellerName, arg.Name)
	var i SellerInsertTagRow
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const sellerProductList = `-- name: SellerProductList :many
SELECT p."id",
    p."name",
    p."image_id" AS "image_url",
    p."price",
    p."sales",
    p."stock",
    p."enabled"
FROM "product" p
    JOIN "shop" s ON p."shop_id" = s.id
WHERE s.seller_name = $1
ORDER BY "sales" DESC
LIMIT $2 OFFSET $3
`

type SellerProductListParams struct {
	SellerName string `json:"seller_name" param:"seller_name"`
	Limit      int64  `json:"limit"`
	Offset     int64  `json:"offset"`
}

type SellerProductListRow struct {
	ID       int32          `json:"id" param:"id"`
	Name     string         `form:"name" json:"name"`
	ImageUrl string         `json:"image_url"`
	Price    pgtype.Numeric `json:"price" swaggertype:"number"`
	Sales    int32          `json:"sales"`
	Stock    int32          `form:"stock" json:"stock"`
	Enabled  bool           `form:"enabled" json:"enabled"`
}

func (q *Queries) SellerProductList(ctx context.Context, arg SellerProductListParams) ([]SellerProductListRow, error) {
	rows, err := q.db.Query(ctx, sellerProductList, arg.SellerName, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SellerProductListRow{}
	for rows.Next() {
		var i SellerProductListRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ImageUrl,
			&i.Price,
			&i.Sales,
			&i.Stock,
			&i.Enabled,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sellerReport = `-- name: SellerReport :one
SELECT SUM(order_history.total_price)::decimal(10, 2) AS total_income,
    COUNT(order_history.id) AS order_count
FROM order_history
    LEFT JOIN shop ON order_history.shop_id = shop.id
WHERE shop.seller_name = $1
    AND order_history."created_at" > $2
    AND order_history."created_at" < $2 + INTERVAL '1 month'
`

type SellerReportParams struct {
	SellerName string             `json:"seller_name" param:"seller_name"`
	Time       pgtype.Timestamptz `json:"time" swaggertype:"string"`
}

type SellerReportRow struct {
	TotalIncome pgtype.Numeric `json:"total_income"`
	OrderCount  int64          `json:"order_count"`
}

func (q *Queries) SellerReport(ctx context.Context, arg SellerReportParams) (SellerReportRow, error) {
	row := q.db.QueryRow(ctx, sellerReport, arg.SellerName, arg.Time)
	var i SellerReportRow
	err := row.Scan(&i.TotalIncome, &i.OrderCount)
	return i, err
}

const sellerSearchTag = `-- name: SellerSearchTag :many
SELECT t."id",
    t."name"
FROM "tag" t
    LEFT JOIN "shop" s ON "shop_id" = s.id
WHERE s."seller_name" = $1
    AND t."name" ~* $2
ORDER BY LENGTH(t."name") ASC
LIMIT $3
`

type SellerSearchTagParams struct {
	SellerName string `json:"seller_name" param:"seller_name"`
	Name       string `json:"name"`
	Limit      int64  `json:"limit"`
}

type SellerSearchTagRow struct {
	ID   int32  `json:"id"`
	Name string `json:"name"`
}

func (q *Queries) SellerSearchTag(ctx context.Context, arg SellerSearchTagParams) ([]SellerSearchTagRow, error) {
	rows, err := q.db.Query(ctx, sellerSearchTag, arg.SellerName, arg.Name, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SellerSearchTagRow{}
	for rows.Next() {
		var i SellerSearchTagRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sellerUpdateCouponInfo = `-- name: SellerUpdateCouponInfo :one
UPDATE "coupon" c
SET "type" = COALESCE($3, "type"),
    "name" = COALESCE($4, "name"),
    "description" = COALESCE($5, "description"),
    "discount" = COALESCE($6, "discount"),
    "start_date" = COALESCE($7, "start_date"),
    "expire_date" = COALESCE($8, "expire_date")
WHERE c."id" = $2
    AND "shop_id" =(
        SELECT s."id"
        FROM "shop" s
        WHERE s."seller_name" = $1
            AND s."enabled" = TRUE
    )
RETURNING c."id",
    c."type",
    c."scope",
    c."name",
    c."description",
    c."discount",
    c."start_date",
    c."expire_date"
`

type SellerUpdateCouponInfoParams struct {
	SellerName  string             `json:"seller_name" param:"seller_name"`
	ID          int32              `json:"id" param:"id"`
	Type        CouponType         `json:"type"`
	Name        string             `json:"name"`
	Description string             `json:"description"`
	Discount    pgtype.Numeric     `json:"discount" swaggertype:"number"`
	StartDate   pgtype.Timestamptz `json:"start_date" swaggertype:"string"`
	ExpireDate  pgtype.Timestamptz `json:"expire_date" swaggertype:"string"`
}

type SellerUpdateCouponInfoRow struct {
	ID          int32              `json:"id" param:"id"`
	Type        CouponType         `json:"type"`
	Scope       CouponScope        `json:"scope"`
	Name        string             `json:"name"`
	Description string             `json:"description"`
	Discount    pgtype.Numeric     `json:"discount" swaggertype:"number"`
	StartDate   pgtype.Timestamptz `json:"start_date" swaggertype:"string"`
	ExpireDate  pgtype.Timestamptz `json:"expire_date" swaggertype:"string"`
}

func (q *Queries) SellerUpdateCouponInfo(ctx context.Context, arg SellerUpdateCouponInfoParams) (SellerUpdateCouponInfoRow, error) {
	row := q.db.QueryRow(ctx, sellerUpdateCouponInfo,
		arg.SellerName,
		arg.ID,
		arg.Type,
		arg.Name,
		arg.Description,
		arg.Discount,
		arg.StartDate,
		arg.ExpireDate,
	)
	var i SellerUpdateCouponInfoRow
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Scope,
		&i.Name,
		&i.Description,
		&i.Discount,
		&i.StartDate,
		&i.ExpireDate,
	)
	return i, err
}

const sellerUpdateInfo = `-- name: SellerUpdateInfo :one
UPDATE "shop"
SET "image_id" = CASE
        WHEN $5::TEXT = '' THEN "image_id"
        ELSE $5::TEXT
    END,
    "name" = COALESCE($2, "name"),
    "description" = COALESCE($3, "description"),
    "enabled" = COALESCE($4, "enabled")
WHERE "seller_name" = $1
RETURNING "name",
    "image_id" AS "image_url",
    "description",
    "enabled"
`

type SellerUpdateInfoParams struct {
	SellerName  string `json:"seller_name" param:"seller_name"`
	Name        string `form:"name" json:"name"`
	Description string `form:"description" json:"description"`
	Enabled     bool   `form:"enabled" json:"enabled"`
	ImageID     string `json:"image_id"`
}

type SellerUpdateInfoRow struct {
	Name        string `form:"name" json:"name"`
	ImageUrl    string `json:"image_url" swaggertype:"string"`
	Description string `form:"description" json:"description"`
	Enabled     bool   `form:"enabled" json:"enabled"`
}

func (q *Queries) SellerUpdateInfo(ctx context.Context, arg SellerUpdateInfoParams) (SellerUpdateInfoRow, error) {
	row := q.db.QueryRow(ctx, sellerUpdateInfo,
		arg.SellerName,
		arg.Name,
		arg.Description,
		arg.Enabled,
		arg.ImageID,
	)
	var i SellerUpdateInfoRow
	err := row.Scan(
		&i.Name,
		&i.ImageUrl,
		&i.Description,
		&i.Enabled,
	)
	return i, err
}

const sellerUpdateOrderStatus = `-- name: SellerUpdateOrderStatus :one
UPDATE "order_history" oh
SET "status" = $3
WHERE "shop_id" =(
        SELECT s."id"
        FROM "shop" s
        WHERE s."seller_name" = $1
            AND s."enabled" = TRUE
    )
    AND oh."id" = $2
    AND oh."status" = $4
RETURNING oh."id",
    oh."shipment",
    oh."total_price",
    oh."status",
    oh."created_at"
`

type SellerUpdateOrderStatusParams struct {
	SellerName    string      `json:"seller_name" param:"seller_name"`
	ID            int32       `json:"id" param:"id"`
	SetStatus     OrderStatus `json:"set_status"`
	CurrentStatus OrderStatus `json:"current_status"`
}

type SellerUpdateOrderStatusRow struct {
	ID         int32              `json:"id" param:"id"`
	Shipment   int32              `json:"shipment"`
	TotalPrice int32              `json:"total_price"`
	Status     OrderStatus        `json:"status"`
	CreatedAt  pgtype.Timestamptz `json:"created_at" swaggertype:"string"`
}

func (q *Queries) SellerUpdateOrderStatus(ctx context.Context, arg SellerUpdateOrderStatusParams) (SellerUpdateOrderStatusRow, error) {
	row := q.db.QueryRow(ctx, sellerUpdateOrderStatus,
		arg.SellerName,
		arg.ID,
		arg.SetStatus,
		arg.CurrentStatus,
	)
	var i SellerUpdateOrderStatusRow
	err := row.Scan(
		&i.ID,
		&i.Shipment,
		&i.TotalPrice,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const sellerUpdateProductInfo = `-- name: SellerUpdateProductInfo :one
UPDATE "product" p
SET "name" = COALESCE($3, "name"),
    "description" = COALESCE($4, "description"),
    "price" = COALESCE($5, "price"),
    "image_id" = CASE
        WHEN $9::TEXT = '' THEN "image_id"
        ELSE $9::TEXT
    END,
    "expire_date" = COALESCE($6, "expire_date"),
    "enabled" = COALESCE($7, "enabled"),
    "stock" = COALESCE($8, "stock"),
    "edit_date" = NOW(),
    "version" = "version" + 1
WHERE "shop_id" =(
        SELECT s."id"
        FROM "shop" s
        WHERE s."seller_name" = $1
            AND s."enabled" = TRUE
    )
    AND p."id" = $2
RETURNING "id",
    "name",
    "description",
    "price",
    "image_id" AS "image_url",
    "expire_date",
    "edit_date",
    "stock",
    "sales",
    "enabled"
`

type SellerUpdateProductInfoParams struct {
	SellerName  string             `json:"seller_name" param:"seller_name"`
	ID          int32              `json:"id" param:"id"`
	Name        string             `form:"name" json:"name"`
	Description string             `form:"description" json:"description"`
	Price       pgtype.Numeric     `json:"price" swaggertype:"number"`
	ExpireDate  pgtype.Timestamptz `json:"expire_date" swaggertype:"string"`
	Enabled     bool               `form:"enabled" json:"enabled"`
	Stock       int32              `form:"stock" json:"stock"`
	ImageID     string             `json:"image_id"`
}

type SellerUpdateProductInfoRow struct {
	ID          int32              `json:"id" param:"id"`
	Name        string             `form:"name" json:"name"`
	Description string             `form:"description" json:"description"`
	Price       pgtype.Numeric     `json:"price" swaggertype:"number"`
	ImageUrl    string             `json:"image_url"`
	ExpireDate  pgtype.Timestamptz `json:"expire_date" swaggertype:"string"`
	EditDate    pgtype.Timestamptz `json:"edit_date" swaggertype:"string"`
	Stock       int32              `form:"stock" json:"stock"`
	Sales       int32              `json:"sales"`
	Enabled     bool               `form:"enabled" json:"enabled"`
}

func (q *Queries) SellerUpdateProductInfo(ctx context.Context, arg SellerUpdateProductInfoParams) (SellerUpdateProductInfoRow, error) {
	row := q.db.QueryRow(ctx, sellerUpdateProductInfo,
		arg.SellerName,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.ExpireDate,
		arg.Enabled,
		arg.Stock,
		arg.ImageID,
	)
	var i SellerUpdateProductInfoRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.ImageUrl,
		&i.ExpireDate,
		&i.EditDate,
		&i.Stock,
		&i.Sales,
		&i.Enabled,
	)
	return i, err
}
