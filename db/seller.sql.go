// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: seller.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteCoupon = `-- name: DeleteCoupon :exec

DELETE FROM "coupon" WHERE "id" = $1 AND "shop_id"=$2
`

type DeleteCouponParams struct {
	ID     int32 `json:"id"`
	ShopID int32 `json:"shop_id"`
}

func (q *Queries) DeleteCoupon(ctx context.Context, arg DeleteCouponParams) error {
	_, err := q.db.Exec(ctx, deleteCoupon, arg.ID, arg.ShopID)
	return err
}

const deleteProduct = `-- name: DeleteProduct :exec

UPDATE "product"
SET "enabled" = false
WHERE "id" = $1 AND "shop_id" = $2
`

type DeleteProductParams struct {
	ID     int32 `json:"id"`
	ShopID int32 `json:"shop_id"`
}

func (q *Queries) DeleteProduct(ctx context.Context, arg DeleteProductParams) error {
	_, err := q.db.Exec(ctx, deleteProduct, arg.ID, arg.ShopID)
	return err
}

const getSellerInfo = `-- name: GetSellerInfo :one

SELECT id, seller_name, image_id, name, description, enabled FROM "shop" WHERE "id" = $1
`

func (q *Queries) GetSellerInfo(ctx context.Context, id int32) (Shop, error) {
	row := q.db.QueryRow(ctx, getSellerInfo, id)
	var i Shop
	err := row.Scan(
		&i.ID,
		&i.SellerName,
		&i.ImageID,
		&i.Name,
		&i.Description,
		&i.Enabled,
	)
	return i, err
}

const insertTag = `-- name: InsertTag :one

INSERT INTO "tag" ( "shop_id", "name") VALUES ($1,$2) RETURNING "id"
`

type InsertTagParams struct {
	ShopID int32  `json:"shop_id"`
	Name   string `json:"name"`
}

func (q *Queries) InsertTag(ctx context.Context, arg InsertTagParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertTag, arg.ShopID, arg.Name)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const orderDetail = `-- name: OrderDetail :one

SELECT order_id, product_id, product_version, quantity, id, version, name, description, price, image_id
FROM "order_detail"
    LEFT JOIN "product_archive" ON "order_detail"."product_id" = "product"."id" AND "order_detail"."version" = "product"."id"
WHERE "order_id" = $1
`

type OrderDetailRow struct {
	OrderID        int32          `json:"order_id"`
	ProductID      int32          `json:"product_id"`
	ProductVersion int32          `json:"product_version"`
	Quantity       int32          `json:"quantity"`
	ID             pgtype.Int4    `json:"id"`
	Version        pgtype.Int4    `json:"version"`
	Name           pgtype.Text    `json:"name"`
	Description    pgtype.Text    `json:"description"`
	Price          pgtype.Numeric `json:"price"`
	ImageID        pgtype.UUID    `json:"image_id"`
}

func (q *Queries) OrderDetail(ctx context.Context, orderID int32) (OrderDetailRow, error) {
	row := q.db.QueryRow(ctx, orderDetail, orderID)
	var i OrderDetailRow
	err := row.Scan(
		&i.OrderID,
		&i.ProductID,
		&i.ProductVersion,
		&i.Quantity,
		&i.ID,
		&i.Version,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.ImageID,
	)
	return i, err
}

const searchTag = `-- name: SearchTag :many

SELECT "id", "name"
FROM "tag"
WHERE
    "shop_id" = $1
    AND "name" LIKE $2 || '%'
ORDER BY LEN("name")
LIMIT 10
`

type SearchTagParams struct {
	ShopID  int32       `json:"shop_id"`
	Column2 pgtype.Text `json:"column_2"`
}

type SearchTagRow struct {
	ID   int32  `json:"id"`
	Name string `json:"name"`
}

func (q *Queries) SearchTag(ctx context.Context, arg SearchTagParams) ([]SearchTagRow, error) {
	rows, err := q.db.Query(ctx, searchTag, arg.ShopID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchTagRow
	for rows.Next() {
		var i SearchTagRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sellerGetCoupon = `-- name: SellerGetCoupon :many

SELECT
    "id",
    "type",
    "shop_id",
    "name",
    "discount",
    "expire_date"
FROM "coupon"
WHERE "shop_id" = $1
ORDER BY "start_date" DESC
LIMIT $2
OFFSET $3
`

type SellerGetCouponParams struct {
	ShopID int32 `json:"shop_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type SellerGetCouponRow struct {
	ID         int32              `json:"id"`
	Type       CouponType         `json:"type"`
	ShopID     int32              `json:"shop_id"`
	Name       string             `json:"name"`
	Discount   pgtype.Numeric     `json:"discount"`
	ExpireDate pgtype.Timestamptz `json:"expire_date"`
}

func (q *Queries) SellerGetCoupon(ctx context.Context, arg SellerGetCouponParams) ([]SellerGetCouponRow, error) {
	rows, err := q.db.Query(ctx, sellerGetCoupon, arg.ShopID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SellerGetCouponRow
	for rows.Next() {
		var i SellerGetCouponRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.ShopID,
			&i.Name,
			&i.Discount,
			&i.ExpireDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sellerGetCouponDetail = `-- name: SellerGetCouponDetail :one

SELECT id, type, shop_id, name, description, discount, start_date, expire_date FROM "coupon" WHERE "id" = $1 and "shop_id" = $2
`

type SellerGetCouponDetailParams struct {
	ID     int32 `json:"id"`
	ShopID int32 `json:"shop_id"`
}

func (q *Queries) SellerGetCouponDetail(ctx context.Context, arg SellerGetCouponDetailParams) (Coupon, error) {
	row := q.db.QueryRow(ctx, sellerGetCouponDetail, arg.ID, arg.ShopID)
	var i Coupon
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.ShopID,
		&i.Name,
		&i.Description,
		&i.Discount,
		&i.StartDate,
		&i.ExpireDate,
	)
	return i, err
}

const sellerGetOrder = `-- name: SellerGetOrder :many

SELECT
    "id",
    "shop_id",
    "shipment",
    "total_price",
    "status",
    "created_at"
FROM "order_history"
WHERE "shop_id" = $1
ORDER BY "created_at" DESC
LIMIT $2
OFFSET $3
`

type SellerGetOrderParams struct {
	ShopID int32 `json:"shop_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type SellerGetOrderRow struct {
	ID         int32              `json:"id"`
	ShopID     int32              `json:"shop_id"`
	Shipment   int32              `json:"shipment"`
	TotalPrice int32              `json:"total_price"`
	Status     OrderStatus        `json:"status"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) SellerGetOrder(ctx context.Context, arg SellerGetOrderParams) ([]SellerGetOrderRow, error) {
	rows, err := q.db.Query(ctx, sellerGetOrder, arg.ShopID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SellerGetOrderRow
	for rows.Next() {
		var i SellerGetOrderRow
		if err := rows.Scan(
			&i.ID,
			&i.ShopID,
			&i.Shipment,
			&i.TotalPrice,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sellerGetReport = `-- name: SellerGetReport :many



INSERT INTO
    "product" (
        "version",
        "shop_id",
        "name",
        "description",
        "price",
        "image_id",
        "exp_date"
    )
VALUES (0, $1, $2, $3, $4, $5, $6)
RETURNING "id"
`

type SellerGetReportParams struct {
	ShopID      int32              `json:"shop_id"`
	Name        string             `json:"name"`
	Description string             `json:"description"`
	Price       pgtype.Numeric     `json:"price"`
	ImageID     pgtype.UUID        `json:"image_id"`
	ExpDate     pgtype.Timestamptz `json:"exp_date"`
}

func (q *Queries) SellerGetReport(ctx context.Context, arg SellerGetReportParams) ([]int32, error) {
	rows, err := q.db.Query(ctx, sellerGetReport,
		arg.ShopID,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.ImageID,
		arg.ExpDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sellerInsertCoupon = `-- name: SellerInsertCoupon :one

INSERT INTO
    "coupon" (
        "type",
        "shop_id",
        "description",
        "discount",
        "start_date",
        "expire_date"
    )
VALUES ($1, $2, $3, $4, NOW(), $5)
RETURNING "id"
`

type SellerInsertCouponParams struct {
	Type        CouponType         `json:"type"`
	ShopID      int32              `json:"shop_id"`
	Description string             `json:"description"`
	Discount    pgtype.Numeric     `json:"discount"`
	ExpireDate  pgtype.Timestamptz `json:"expire_date"`
}

func (q *Queries) SellerInsertCoupon(ctx context.Context, arg SellerInsertCouponParams) (int32, error) {
	row := q.db.QueryRow(ctx, sellerInsertCoupon,
		arg.Type,
		arg.ShopID,
		arg.Description,
		arg.Discount,
		arg.ExpireDate,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const updateCouponInfo = `-- name: UpdateCouponInfo :exec

UPDATE "coupon"
SET
    "type" = CASE
        WHEN $3 IS NOT NULL THEN $3
        ELSE "type"
    END,
    "description" = CASE
        WHEN $4 IS NOT NULL THEN $4
        ELSE "description"
    END,
    "discount" = CASE
        WHEN $5 IS NOT NULL THEN $5
        ELSE "discount"
    END,
    "start_date" = CASE
        WHEN $6 IS NOT NULL THEN $6
        ELSE "start_date"
    END,
    "expire_date" = CASE
        WHEN $7 IS NOT NULL THEN $7
        ELSE "expire_date"
    END
WHERE "id" = $1 AND "shop_id" = $2
`

type UpdateCouponInfoParams struct {
	ID          int32              `json:"id"`
	ShopID      int32              `json:"shop_id"`
	Type        CouponType         `json:"type"`
	Description string             `json:"description"`
	Discount    pgtype.Numeric     `json:"discount"`
	StartDate   pgtype.Timestamptz `json:"start_date"`
	ExpireDate  pgtype.Timestamptz `json:"expire_date"`
}

func (q *Queries) UpdateCouponInfo(ctx context.Context, arg UpdateCouponInfoParams) error {
	_, err := q.db.Exec(ctx, updateCouponInfo,
		arg.ID,
		arg.ShopID,
		arg.Type,
		arg.Description,
		arg.Discount,
		arg.StartDate,
		arg.ExpireDate,
	)
	return err
}

const updateProductInfo = `-- name: UpdateProductInfo :exec

UPDATE "product"
SET
    "name" = CASE
        WHEN $3 IS NOT NULL THEN $3
        ELSE "description"
    END,
    "description" = CASE
        WHEN $4 IS NOT NULL THEN $4
        ELSE "discount"
    END,
    "price" = CASE
        WHEN $5 IS NOT NULL THEN $5
        ELSE "start_date"
    END,
    "image_id" = CASE
        WHEN $6 IS NOT NULL THEN $6
        ELSE "image_id"
    END,
    "exp_date" = CASE
        WHEN $7 IS NOT NULL THEN $7
        ELSE "exp_date"
    END,
    "edit_date" = NOW(),
    "version" = "version" + 1
WHERE "id" = $1 AND "shop_id" = $2
`

type UpdateProductInfoParams struct {
	ID          int32              `json:"id"`
	ShopID      int32              `json:"shop_id"`
	Name        string             `json:"name"`
	Description string             `json:"description"`
	Price       pgtype.Numeric     `json:"price"`
	ImageID     pgtype.UUID        `json:"image_id"`
	ExpDate     pgtype.Timestamptz `json:"exp_date"`
}

func (q *Queries) UpdateProductInfo(ctx context.Context, arg UpdateProductInfoParams) error {
	_, err := q.db.Exec(ctx, updateProductInfo,
		arg.ID,
		arg.ShopID,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.ImageID,
		arg.ExpDate,
	)
	return err
}

const updateSellerInfo = `-- name: UpdateSellerInfo :exec

UPDATE "shop"
SET
    "seller_name" = CASE
        WHEN $2 IS NOT NULL THEN $2
        ELSE "seller_name"
    END,
    "image_id" = CASE
        WHEN $3 IS NOT NULL THEN $3
        ELSE "image_id"
    END,
    "name" = CASE
        WHEN $4 IS NOT NULL THEN $4
        ELSE "name"
    END,
    "description" = CASE
        WHEN $5 IS NOT NULL THEN $5
        ELSE "description"
    END,
    "enabled" = CASE
        WHEN $6 IS NOT NULL THEN $6
        ELSE "enabled"
    END
WHERE "id" = $1
`

type UpdateSellerInfoParams struct {
	ID          int32       `json:"id"`
	SellerName  string      `json:"seller_name"`
	ImageID     pgtype.UUID `json:"image_id"`
	Name        string      `json:"name"`
	Description string      `json:"description"`
	Enabled     bool        `json:"enabled"`
}

func (q *Queries) UpdateSellerInfo(ctx context.Context, arg UpdateSellerInfoParams) error {
	_, err := q.db.Exec(ctx, updateSellerInfo,
		arg.ID,
		arg.SellerName,
		arg.ImageID,
		arg.Name,
		arg.Description,
		arg.Enabled,
	)
	return err
}
