// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: buyer.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getCart = `-- name: GetCart :many

SELECT C."id", S."seller_name"
FROM
    "cart" AS C,
    "user" AS U,
    "shop" AS S
WHERE
    U."username" = $1
    AND U."id" = C."user_id"
    AND C."shop_id" = S."id"
`

type GetCartRow struct {
	ID         int32  `json:"id"`
	SellerName string `json:"seller_name" param:"seller_name"`
}

func (q *Queries) GetCart(ctx context.Context, username string) ([]GetCartRow, error) {
	rows, err := q.db.Query(ctx, getCart, username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCartRow{}
	for rows.Next() {
		var i GetCartRow
		if err := rows.Scan(&i.ID, &i.SellerName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderDetail = `-- name: GetOrderDetail :many

SELECT
    O."product_id",
    P."name",
    P."description",
    P."price",
    P."image_id",
    O."quantity"
FROM
    "order_detail" AS O,
    "product_archive" AS P
WHERE
    O."order_id" = $1
    AND O."product_id" = P."id"
    AND O."product_version" = P."version"
`

type GetOrderDetailRow struct {
	ProductID   int32          `json:"product_id"`
	Name        string         `json:"name"`
	Description string         `json:"description"`
	Price       pgtype.Numeric `json:"price"`
	ImageID     pgtype.UUID    `json:"image_id"`
	Quantity    int32          `json:"quantity"`
}

func (q *Queries) GetOrderDetail(ctx context.Context, orderID int32) ([]GetOrderDetailRow, error) {
	rows, err := q.db.Query(ctx, getOrderDetail, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrderDetailRow{}
	for rows.Next() {
		var i GetOrderDetailRow
		if err := rows.Scan(
			&i.ProductID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.ImageID,
			&i.Quantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderHistory = `-- name: GetOrderHistory :many

SELECT
    O."id",
    s."name",
    s."image_id",
    "shipment",
    "total_price",
    "status",
    "created_at"
FROM
    "order_history" AS O,
    "user" AS U,
    "shop" AS S
WHERE
    U."username" = $1
    AND U."id" = O."user_id"
    AND O."shop_id" = S."id"

ORDER BY "created_at" ASC OFFSET $2 LIMIT $3
`

type GetOrderHistoryParams struct {
	Username string `json:"username"`
	Offset   int32  `json:"offset"`
	Limit    int32  `json:"limit"`
}

type GetOrderHistoryRow struct {
	ID         int32              `json:"id" param:"id"`
	Name       string             `json:"name"`
	ImageID    pgtype.UUID        `json:"image_id"`
	Shipment   int32              `json:"shipment"`
	TotalPrice int32              `json:"total_price"`
	Status     OrderStatus        `json:"status"`
	CreatedAt  pgtype.Timestamptz `json:"-"`
}

func (q *Queries) GetOrderHistory(ctx context.Context, arg GetOrderHistoryParams) ([]GetOrderHistoryRow, error) {
	rows, err := q.db.Query(ctx, getOrderHistory, arg.Username, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrderHistoryRow{}
	for rows.Next() {
		var i GetOrderHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ImageID,
			&i.Shipment,
			&i.TotalPrice,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductInCart = `-- name: GetProductInCart :many

SELECT
    "product_id",
    "quantity"
FROM "cart_product"
WHERE "cart_id" = $1
`

type GetProductInCartRow struct {
	ProductID int32 `json:"product_id"`
	Quantity  int32 `json:"quantity"`
}

func (q *Queries) GetProductInCart(ctx context.Context, cartID int32) ([]GetProductInCartRow, error) {
	rows, err := q.db.Query(ctx, getProductInCart, cartID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductInCartRow{}
	for rows.Next() {
		var i GetProductInCartRow
		if err := rows.Scan(&i.ProductID, &i.Quantity); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
