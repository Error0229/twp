// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: buyer.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addProductToCart = `-- name: AddProductToCart :one


WITH valid_product AS (
        SELECT P."id", S."id"
        FROM
            "product" P,
            "shop" S
        WHERE
            P."shop_id" = S."id"
            AND P."id" = $3
            AND P."enabled" = TRUE
    ),
    -- check product enabled ‚¨ÜÔ∏è
    new_cart AS (
        INSERT INTO
            "cart" ("user_id", "shop_id")
        SELECT
            U."id",
            S."shop_id"
        FROM
            "user" AS U,
            "shop" AS S,
            "product" AS P
        WHERE
            U."username" = $1
            AND S."id" = P."shop_id"
            AND NOT EXISTS (
                SELECT 1
                FROM
                    "cart" AS C
                WHERE
                    C."user_id" = U."id"
                    AND C."shop_id" = S."shop_id"
            ) RETURNING "id"
    ),
    -- create new cart if not exists ‚¨ÜÔ∏è
    existing_cart_product AS (
        UPDATE
            "cart_product" AS CP
        SET
            "quantity" = "quantity" + $2
        FROM
            "cart" AS C,
            "user" AS U
        WHERE
            U."username" = $1
            AND C."user_id" = U."id"
            AND C."id" = CP."cart_id"
            AND CP."product_id" = (
                SELECT "id"
                FROM
                    valid_product
            ) RETURNING 1
    ) -- if the product already exists in the cart, update the quantity ‚¨ÜÔ∏è
INSERT INTO
    -- insert into the cart that have given product ‚¨áÔ∏è
    "cart_product" (
        "cart_id",
        "product_id",
        "quantity"
    )
SELECT
    C."id",
    valid_product."id",
    $2
FROM "cart" C, valid_product
WHERE NOT EXISTS (
        SELECT 1
        FROM
            existing_cart_product
    ) RETURNING (
        SELECT COUNT(*)
        FROM
            "cart_product" CP,
            "cart" C,
            "user" U
        WHERE
            CP."cart_id" = C."id"
            AND U."id" = C."user_id"
            AND U."username" = $1
    )
`

type AddProductToCartParams struct {
	Username string `json:"username"`
	Quantity int32  `json:"quantity"`
	ID       int32  `json:"id" param:"id"`
}

// i hope this works ‚ò†Ô∏è
func (q *Queries) AddProductToCart(ctx context.Context, arg AddProductToCartParams) (int64, error) {
	row := q.db.QueryRow(ctx, addProductToCart, arg.Username, arg.Quantity, arg.ID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteProductInCart = `-- name: DeleteProductInCart :execrows

WITH valid_cart AS (
        SELECT C."id"
        FROM "cart" C
            JOIN "user" u ON u."id" = C."user_id"
        WHERE
            u."username" = $3
            AND C."id" = $1
    ),
    deleted_products AS (
        DELETE FROM
            "cart_product" CP
        WHERE "cart_id" = (
                SELECT "id"
                FROM
                    valid_cart
            )
            AND CP."product_id" = $2 RETURNING 1
    ),
    remaining_products AS (
        SELECT COUNT(*) AS count
        FROM "cart_product"
        WHERE "cart_id" = (
                SELECT "id"
                FROM valid_cart
            )
    )
DELETE FROM "cart" AS üõí
WHERE üõí."id" = $1 AND (
        SELECT count
        FROM remaining_products
    ) = 0
`

type DeleteProductInCartParams struct {
	ID        int32  `json:"id"`
	ProductID int32  `json:"product_id"`
	Username  string `json:"username"`
}

func (q *Queries) DeleteProductInCart(ctx context.Context, arg DeleteProductInCartParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteProductInCart, arg.ID, arg.ProductID, arg.Username)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getCart = `-- name: GetCart :many

SELECT
    C."id",
    S."seller_name",
    S."image_id",
    S."name"
FROM
    "cart" AS C,
    "user" AS U,
    "shop" AS S
WHERE
    U."username" = $1
    AND U."id" = C."user_id"
    AND C."shop_id" = S."id"
`

type GetCartRow struct {
	ID         int32       `json:"id"`
	SellerName string      `json:"seller_name" param:"seller_name"`
	ImageID    pgtype.UUID `json:"image_id"`
	Name       string      `json:"name"`
}

func (q *Queries) GetCart(ctx context.Context, username string) ([]GetCartRow, error) {
	rows, err := q.db.Query(ctx, getCart, username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCartRow{}
	for rows.Next() {
		var i GetCartRow
		if err := rows.Scan(
			&i.ID,
			&i.SellerName,
			&i.ImageID,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderDetail = `-- name: GetOrderDetail :many

SELECT
    O."product_id",
    P."name",
    P."description",
    P."price",
    P."image_id",
    O."quantity"
FROM
    "order_detail" AS O,
    "product_archive" AS P
WHERE
    O."order_id" = $1
    AND O."product_id" = P."id"
    AND O."product_version" = P."version"
`

type GetOrderDetailRow struct {
	ProductID   int32          `json:"product_id"`
	Name        string         `json:"name"`
	Description string         `json:"description"`
	Price       pgtype.Numeric `json:"price" swaggertype:"number"`
	ImageID     pgtype.UUID    `json:"image_id"`
	Quantity    int32          `json:"quantity"`
}

func (q *Queries) GetOrderDetail(ctx context.Context, orderID int32) ([]GetOrderDetailRow, error) {
	rows, err := q.db.Query(ctx, getOrderDetail, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrderDetailRow{}
	for rows.Next() {
		var i GetOrderDetailRow
		if err := rows.Scan(
			&i.ProductID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.ImageID,
			&i.Quantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderHistory = `-- name: GetOrderHistory :many

SELECT
    O."id",
    s."name",
    s."image_id" AS "shop_image_id",
    O."image_id" AS "thumbnail_id",
    "shipment",
    "total_price",
    "status",
    "created_at"
FROM
    "order_history" AS O,
    "user" AS U,
    "shop" AS S
WHERE
    U."username" = $1
    AND U."id" = O."user_id"
    AND O."shop_id" = S."id"

ORDER BY "created_at" ASC OFFSET $2 LIMIT $3
`

type GetOrderHistoryParams struct {
	Username string `json:"username"`
	Offset   int32  `json:"offset"`
	Limit    int32  `json:"limit"`
}

type GetOrderHistoryRow struct {
	ID          int32              `json:"id" param:"id"`
	Name        string             `json:"name"`
	ShopImageID pgtype.UUID        `json:"shop_image_id"`
	ThumbnailID pgtype.UUID        `json:"thumbnail_id"`
	Shipment    int32              `json:"shipment"`
	TotalPrice  int32              `json:"total_price"`
	Status      OrderStatus        `json:"status"`
	CreatedAt   pgtype.Timestamptz `json:"created_at" swaggertype:"string"`
}

func (q *Queries) GetOrderHistory(ctx context.Context, arg GetOrderHistoryParams) ([]GetOrderHistoryRow, error) {
	rows, err := q.db.Query(ctx, getOrderHistory, arg.Username, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrderHistoryRow{}
	for rows.Next() {
		var i GetOrderHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ShopImageID,
			&i.ThumbnailID,
			&i.Shipment,
			&i.TotalPrice,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderInfo = `-- name: GetOrderInfo :one

SELECT
    O."id",
    s."name",
    s."image_id",
    "shipment",
    "total_price",
    "status",
    "created_at", (
        "subtotal" + "shipment" - "total_price"
    ) AS "discount"
FROM
    "order_history" AS O,
    "order_detail" AS D,
    "product_archive" AS P,
    "user" AS U,
    "shop" AS S, (
        SELECT
            SUM(P."price" * D."quantity") AS "subtotal"
        FROM
            "order_detail" AS D,
            "product_archive" AS P
        WHERE
            D."order_id" = $1
            AND D."product_id" = P."id"
            AND D."product_version" = P."version"
    ) AS T
WHERE
    U."username" = $2
    AND O."id" = $1
`

type GetOrderInfoParams struct {
	OrderID  int32  `json:"order_id"`
	Username string `json:"username"`
}

type GetOrderInfoRow struct {
	ID         int32              `json:"id" param:"id"`
	Name       string             `json:"name"`
	ImageID    pgtype.UUID        `json:"image_id"`
	Shipment   int32              `json:"shipment"`
	TotalPrice int32              `json:"total_price"`
	Status     OrderStatus        `json:"status"`
	CreatedAt  pgtype.Timestamptz `json:"created_at" swaggertype:"string"`
	Discount   int32              `json:"discount"`
}

func (q *Queries) GetOrderInfo(ctx context.Context, arg GetOrderInfoParams) (GetOrderInfoRow, error) {
	row := q.db.QueryRow(ctx, getOrderInfo, arg.OrderID, arg.Username)
	var i GetOrderInfoRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ImageID,
		&i.Shipment,
		&i.TotalPrice,
		&i.Status,
		&i.CreatedAt,
		&i.Discount,
	)
	return i, err
}

const getProductInCart = `-- name: GetProductInCart :many

SELECT
    "product_id",
    "name",
    "image_id",
    "price",
    "quantity"
FROM
    "cart_product" AS C,
    "product" AS P
WHERE
    "cart_id" = $1
    AND C."product_id" = P."id"
`

type GetProductInCartRow struct {
	ProductID int32          `json:"product_id"`
	Name      string         `json:"name"`
	ImageID   pgtype.UUID    `json:"image_id"`
	Price     pgtype.Numeric `json:"price"`
	Quantity  int32          `json:"quantity"`
}

func (q *Queries) GetProductInCart(ctx context.Context, cartID int32) ([]GetProductInCartRow, error) {
	rows, err := q.db.Query(ctx, getProductInCart, cartID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductInCartRow{}
	for rows.Next() {
		var i GetProductInCartRow
		if err := rows.Scan(
			&i.ProductID,
			&i.Name,
			&i.ImageID,
			&i.Price,
			&i.Quantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProductInCart = `-- name: UpdateProductInCart :one

UPDATE "cart_product"
SET "quantity" = $3
FROM "user" AS U, "cart" AS C
WHERE
    U."username" = $4
    AND U."id" = C."user_id"
    AND "cart_id" = $1
    AND "product_id" = $2 RETURNING "quantity"
`

type UpdateProductInCartParams struct {
	CartID    int32  `json:"cart_id"`
	ProductID int32  `json:"product_id"`
	Quantity  int32  `json:"quantity"`
	Username  string `json:"username"`
}

func (q *Queries) UpdateProductInCart(ctx context.Context, arg UpdateProductInCartParams) (int32, error) {
	row := q.db.QueryRow(ctx, updateProductInCart,
		arg.CartID,
		arg.ProductID,
		arg.Quantity,
		arg.Username,
	)
	var quantity int32
	err := row.Scan(&quantity)
	return quantity, err
}
