// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: general.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getProductInfo = `-- name: GetProductInfo :one
SELECT
    P."id",
    P."name",
    P."description",
    P."price",
    P."image_id" AS "product_image_url",
    P."expire_date",
    P."stock",
    P."sales",
    S."name" AS "shop_name",
    S."image_id" AS "shop_image_url",
    S."seller_name" AS "seller_name"
FROM
    "product" AS P
    JOIN "shop" S ON S."id" = P."shop_id"
WHERE
    P."id" = $1
    AND P."enabled" = TRUE
`

type GetProductInfoRow struct {
	ID              int32              `json:"id" param:"id"`
	Name            string             `form:"name" json:"name"`
	Description     string             `form:"description" json:"description"`
	Price           pgtype.Numeric     `json:"price" swaggertype:"number"`
	ProductImageUrl string             `json:"product_image_url"`
	ExpireDate      pgtype.Timestamptz `json:"expire_date" swaggertype:"string"`
	Stock           int32              `form:"stock" json:"stock"`
	Sales           int32              `json:"sales"`
	ShopName        string             `form:"name" json:"shop_name"`
	ShopImageUrl    string             `json:"shop_image_url" swaggertype:"string"`
	SellerName      string             `json:"seller_name" param:"seller_name"`
}

func (q *Queries) GetProductInfo(ctx context.Context, id int32) (GetProductInfoRow, error) {
	row := q.db.QueryRow(ctx, getProductInfo, id)
	var i GetProductInfoRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.ProductImageUrl,
		&i.ExpireDate,
		&i.Stock,
		&i.Sales,
		&i.ShopName,
		&i.ShopImageUrl,
		&i.SellerName,
	)
	return i, err
}

const getProductTags = `-- name: GetProductTags :many
SELECT
    T."id",
    T."name"
FROM
    "tag" T,
    "product_tag" PT
WHERE
    PT."product_id" = $1
    AND PT."tag_id" = T."id"
`

type GetProductTagsRow struct {
	ID   int32  `json:"id"`
	Name string `json:"name"`
}

func (q *Queries) GetProductTags(ctx context.Context, productID int32) ([]GetProductTagsRow, error) {
	rows, err := q.db.Query(ctx, getProductTags, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductTagsRow{}
	for rows.Next() {
		var i GetProductTagsRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsFromNearByShop = `-- name: GetProductsFromNearByShop :many
WITH nearby_shop AS (
    SELECT
        S."id" AS "id"
    FROM
        "shop" S
    WHERE
        S."enabled" = TRUE
        AND (
            SELECT
                COUNT("product"."id")
            FROM
                "product"
            WHERE
                "product"."shop_id" = S."id"
                AND "product"."enabled" = TRUE) >= 1
        ORDER BY
            RANDOM() -- implement distance in future
        LIMIT 1
)
SELECT
    "id",
    "name",
    "description",
    "price",
    "image_id" AS "image_url",
    "sales"
FROM
    "product"
WHERE
    "shop_id" =(
        SELECT
            "id"
        FROM
            nearby_shop)
    AND "enabled" = TRUE
ORDER BY
    "sales" DESC
LIMIT 4
`

type GetProductsFromNearByShopRow struct {
	ID          int32          `json:"id" param:"id"`
	Name        string         `form:"name" json:"name"`
	Description string         `form:"description" json:"description"`
	Price       pgtype.Numeric `json:"price" swaggertype:"number"`
	ImageUrl    string         `json:"image_url"`
	Sales       int32          `json:"sales"`
}

func (q *Queries) GetProductsFromNearByShop(ctx context.Context) ([]GetProductsFromNearByShopRow, error) {
	rows, err := q.db.Query(ctx, getProductsFromNearByShop)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductsFromNearByShopRow{}
	for rows.Next() {
		var i GetProductsFromNearByShopRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.ImageUrl,
			&i.Sales,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsFromPopularShop = `-- name: GetProductsFromPopularShop :many
WITH popular_shop AS (
    SELECT
        S."id" AS "id"
    FROM
        "shop" S,
        "order_history" O
    WHERE
        S."id" = O."shop_id"
        AND S."enabled" = TRUE
        AND O."created_at" >=(NOW() -(INTERVAL '1 month'))
        AND (
            SELECT
                COUNT("product"."id")
            FROM
                "product"
            WHERE
                "product"."shop_id" = S."id"
                AND "product"."enabled" = TRUE) >= 1
        GROUP BY
            S."id"
        ORDER BY
            COUNT(O."id") DESC
        LIMIT 1
)
SELECT
    "id",
    "name",
    "description",
    "price",
    "image_id" AS "image_url",
    "sales"
FROM
    "product"
WHERE
    "shop_id" =(
        SELECT
            "id"
        FROM
            popular_shop)
    AND "enabled" = TRUE
ORDER BY
    "sales" DESC
LIMIT 4
`

type GetProductsFromPopularShopRow struct {
	ID          int32          `json:"id" param:"id"`
	Name        string         `form:"name" json:"name"`
	Description string         `form:"description" json:"description"`
	Price       pgtype.Numeric `json:"price" swaggertype:"number"`
	ImageUrl    string         `json:"image_url"`
	Sales       int32          `json:"sales"`
}

func (q *Queries) GetProductsFromPopularShop(ctx context.Context) ([]GetProductsFromPopularShopRow, error) {
	rows, err := q.db.Query(ctx, getProductsFromPopularShop)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductsFromPopularShopRow{}
	for rows.Next() {
		var i GetProductsFromPopularShopRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.ImageUrl,
			&i.Sales,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRandomProducts = `-- name: GetRandomProducts :many
SELECT
    "id",
    "name",
    "description",
    "price",
    "image_id" AS "image_url",
    "sales"
FROM
    "product"
WHERE
    "enabled" = TRUE
ORDER BY
    "image_id" -- random but stable
LIMIT $1 OFFSET $2
`

type GetRandomProductsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

type GetRandomProductsRow struct {
	ID          int32          `json:"id" param:"id"`
	Name        string         `form:"name" json:"name"`
	Description string         `form:"description" json:"description"`
	Price       pgtype.Numeric `json:"price" swaggertype:"number"`
	ImageUrl    string         `json:"image_url"`
	Sales       int32          `json:"sales"`
}

func (q *Queries) GetRandomProducts(ctx context.Context, arg GetRandomProductsParams) ([]GetRandomProductsRow, error) {
	rows, err := q.db.Query(ctx, getRandomProducts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRandomProductsRow{}
	for rows.Next() {
		var i GetRandomProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.ImageUrl,
			&i.Sales,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSellerNameByShopID = `-- name: GetSellerNameByShopID :one
SELECT
    "seller_name"
FROM
    "shop"
WHERE
    "id" = $1
`

func (q *Queries) GetSellerNameByShopID(ctx context.Context, id int32) (string, error) {
	row := q.db.QueryRow(ctx, getSellerNameByShopID, id)
	var seller_name string
	err := row.Scan(&seller_name)
	return seller_name, err
}

const getShopCoupons = `-- name: GetShopCoupons :many
SELECT
    "id",
    "type",
    "scope",
    "name",
    "description",
    "discount",
    "start_date",
    "expire_date"
FROM
    "coupon"
WHERE
    "shop_id" = $1
    OR "scope" = 'global'
ORDER BY
    "id" ASC
LIMIT $2 OFFSET $3
`

type GetShopCouponsParams struct {
	ShopID pgtype.Int4 `json:"shop_id"`
	Limit  int64       `json:"limit"`
	Offset int64       `json:"offset"`
}

type GetShopCouponsRow struct {
	ID          int32              `json:"id" param:"id"`
	Type        CouponType         `json:"type"`
	Scope       CouponScope        `json:"scope"`
	Name        string             `json:"name"`
	Description string             `json:"description"`
	Discount    pgtype.Numeric     `json:"discount" swaggertype:"number"`
	StartDate   pgtype.Timestamptz `json:"start_date" swaggertype:"string"`
	ExpireDate  pgtype.Timestamptz `json:"expire_date" swaggertype:"string"`
}

func (q *Queries) GetShopCoupons(ctx context.Context, arg GetShopCouponsParams) ([]GetShopCouponsRow, error) {
	rows, err := q.db.Query(ctx, getShopCoupons, arg.ShopID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetShopCouponsRow{}
	for rows.Next() {
		var i GetShopCouponsRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Scope,
			&i.Name,
			&i.Description,
			&i.Discount,
			&i.StartDate,
			&i.ExpireDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShopInfo = `-- name: GetShopInfo :one
SELECT
    "seller_name",
    "image_id" AS "image_url",
    "name",
    "description"
FROM
    "shop"
WHERE
    "seller_name" = $1
    AND "enabled" = TRUE
`

type GetShopInfoRow struct {
	SellerName  string `json:"seller_name" param:"seller_name"`
	ImageUrl    string `json:"image_url" swaggertype:"string"`
	Name        string `form:"name" json:"name"`
	Description string `form:"description" json:"description"`
}

func (q *Queries) GetShopInfo(ctx context.Context, sellerName string) (GetShopInfoRow, error) {
	row := q.db.QueryRow(ctx, getShopInfo, sellerName)
	var i GetShopInfoRow
	err := row.Scan(
		&i.SellerName,
		&i.ImageUrl,
		&i.Name,
		&i.Description,
	)
	return i, err
}

const getShopProducts = `-- name: GetShopProducts :many
SELECT
    P."id",
    P."name",
    P."description",
    P."price",
    P."image_id" AS "image_url",
    P."expire_date",
    P."stock",
    P."sales"
FROM
    "product" P,
    "shop" S
WHERE
    S."seller_name" = $1
    AND P."shop_id" = S."id"
    AND P."enabled" = TRUE
ORDER BY
    P."sales" DESC
LIMIT $2 OFFSET $3
`

type GetShopProductsParams struct {
	SellerName string `json:"seller_name" param:"seller_name"`
	Limit      int64  `json:"limit"`
	Offset     int64  `json:"offset"`
}

type GetShopProductsRow struct {
	ID          int32              `json:"id" param:"id"`
	Name        string             `form:"name" json:"name"`
	Description string             `form:"description" json:"description"`
	Price       pgtype.Numeric     `json:"price" swaggertype:"number"`
	ImageUrl    string             `json:"image_url"`
	ExpireDate  pgtype.Timestamptz `json:"expire_date" swaggertype:"string"`
	Stock       int32              `form:"stock" json:"stock"`
	Sales       int32              `json:"sales"`
}

func (q *Queries) GetShopProducts(ctx context.Context, arg GetShopProductsParams) ([]GetShopProductsRow, error) {
	rows, err := q.db.Query(ctx, getShopProducts, arg.SellerName, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetShopProductsRow{}
	for rows.Next() {
		var i GetShopProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.ImageUrl,
			&i.ExpireDate,
			&i.Stock,
			&i.Sales,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagInfo = `-- name: GetTagInfo :one
SELECT
    "id",
    "name"
FROM
    "tag"
WHERE
    "id" = $1
`

type GetTagInfoRow struct {
	ID   int32  `json:"id"`
	Name string `json:"name"`
}

func (q *Queries) GetTagInfo(ctx context.Context, id int32) (GetTagInfoRow, error) {
	row := q.db.QueryRow(ctx, getTagInfo, id)
	var i GetTagInfoRow
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const searchProducts = `-- name: SearchProducts :many
SELECT
    "id",
    "name",
    "price",
    "image_url",
    "sales"
FROM
    search_products($1, NULL, $2, $3, $4, $5, $6, $7, $8, $9, $10)
`

type SearchProductsParams struct {
	Query     string         `json:"query"`
	MinPrice  pgtype.Numeric `json:"min_price"`
	MaxPrice  pgtype.Numeric `json:"max_price"`
	MinStock  pgtype.Int4    `json:"min_stock"`
	MaxStock  pgtype.Int4    `json:"max_stock"`
	HasCoupon pgtype.Bool    `json:"has_coupon"`
	SortBy    string         `json:"sort_by"`
	Order     string         `json:"order"`
	Offset    int32          `json:"offset"`
	Limit     int32          `json:"limit"`
}

type SearchProductsRow struct {
	ID       pgtype.Int4    `json:"id"`
	Name     string         `json:"name"`
	Price    pgtype.Numeric `json:"price"`
	ImageUrl string         `json:"image_url"`
	Sales    pgtype.Int4    `json:"sales"`
}

func (q *Queries) SearchProducts(ctx context.Context, arg SearchProductsParams) ([]SearchProductsRow, error) {
	rows, err := q.db.Query(ctx, searchProducts,
		arg.Query,
		arg.MinPrice,
		arg.MaxPrice,
		arg.MinStock,
		arg.MaxStock,
		arg.HasCoupon,
		arg.SortBy,
		arg.Order,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchProductsRow{}
	for rows.Next() {
		var i SearchProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Price,
			&i.ImageUrl,
			&i.Sales,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProductsByShop = `-- name: SearchProductsByShop :many
WITH shop_id AS (
    SELECT
        "id"
    FROM
        "shop"
    WHERE
        "seller_name" = $1
        AND "enabled" = TRUE
)
SELECT
    "id",
    "name",
    "price",
    "image_url",
    "sales"
FROM
    search_products($2,(
            SELECT
                "id"
            FROM shop_id), $3, $4, $5, $6, $7, $8, $9, $10, $11)
`

type SearchProductsByShopParams struct {
	SellerName string         `json:"seller_name" param:"seller_name"`
	Query      string         `json:"query"`
	MinPrice   pgtype.Numeric `json:"min_price"`
	MaxPrice   pgtype.Numeric `json:"max_price"`
	MinStock   pgtype.Int4    `json:"min_stock"`
	MaxStock   pgtype.Int4    `json:"max_stock"`
	HasCoupon  pgtype.Bool    `json:"has_coupon"`
	SortBy     string         `json:"sort_by"`
	Order      string         `json:"order"`
	Offset     int32          `json:"offset"`
	Limit      int32          `json:"limit"`
}

type SearchProductsByShopRow struct {
	ID       pgtype.Int4    `json:"id"`
	Name     string         `json:"name"`
	Price    pgtype.Numeric `json:"price"`
	ImageUrl string         `json:"image_url"`
	Sales    pgtype.Int4    `json:"sales"`
}

func (q *Queries) SearchProductsByShop(ctx context.Context, arg SearchProductsByShopParams) ([]SearchProductsByShopRow, error) {
	rows, err := q.db.Query(ctx, searchProductsByShop,
		arg.SellerName,
		arg.Query,
		arg.MinPrice,
		arg.MaxPrice,
		arg.MinStock,
		arg.MaxStock,
		arg.HasCoupon,
		arg.SortBy,
		arg.Order,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchProductsByShopRow{}
	for rows.Next() {
		var i SearchProductsByShopRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Price,
			&i.ImageUrl,
			&i.Sales,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchShops = `-- name: SearchShops :many
SELECT
    "name",
    "seller_name",
    "image_url"
FROM
    search_shop($1, $2, $3)
`

type SearchShopsParams struct {
	Query  string `json:"query"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

type SearchShopsRow struct {
	Name       string `json:"name"`
	SellerName string `json:"seller_name"`
	ImageUrl   string `json:"image_url"`
}

func (q *Queries) SearchShops(ctx context.Context, arg SearchShopsParams) ([]SearchShopsRow, error) {
	rows, err := q.db.Query(ctx, searchShops, arg.Query, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchShopsRow{}
	for rows.Next() {
		var i SearchShopsRow
		if err := rows.Scan(&i.Name, &i.SellerName, &i.ImageUrl); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const shopExists = `-- name: ShopExists :one
SELECT
    "id"
FROM
    "shop" AS s
WHERE
    s."seller_name" = $1
    AND s."enabled" = TRUE
`

func (q *Queries) ShopExists(ctx context.Context, sellerName string) (int32, error) {
	row := q.db.QueryRow(ctx, shopExists, sellerName)
	var id int32
	err := row.Scan(&id)
	return id, err
}
