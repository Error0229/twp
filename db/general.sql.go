// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: general.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getProductInfo = `-- name: GetProductInfo :one
SELECT "id",
    "name",
    "description",
    "price",
    "image_id",
    "expire_date",
    "stock",
    "sales"
FROM "product"
WHERE "id" = $1
    AND "enabled" = TRUE
`

type GetProductInfoRow struct {
	ID          int32              `json:"id" param:"id"`
	Name        string             `form:"name" json:"name"`
	Description string             `form:"description" json:"description"`
	Price       pgtype.Numeric     `json:"price" swaggertype:"number"`
	ImageID     string             `json:"image_id"`
	ExpireDate  pgtype.Timestamptz `json:"expire_date" swaggertype:"string"`
	Stock       int32              `form:"stock" json:"stock"`
	Sales       int32              `json:"sales"`
}

func (q *Queries) GetProductInfo(ctx context.Context, id int32) (GetProductInfoRow, error) {
	row := q.db.QueryRow(ctx, getProductInfo, id)
	var i GetProductInfoRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.ImageID,
		&i.ExpireDate,
		&i.Stock,
		&i.Sales,
	)
	return i, err
}

const getProductsFromNearByShop = `-- name: GetProductsFromNearByShop :many
WITH nearby_shop AS (
    SELECT S."id" AS "id"
    FROM "shop" S
    WHERE S."enabled" = TRUE
        AND (
            SELECt COUNT("product"."id")
            FROM "product"
            WHERE "product"."shop_id" = S."id"
                AND "product"."enabled" = TRUE
        ) >= 1
    ORDER BY RANDOM() -- implement distance in future
    LIMIT 1
)
SELECT "id",
    "name",
    "description",
    "price",
    "image_id",
    "sales"
FROM "product"
WHERE "shop_id" = (
        SELECT "id"
        FROM nearby_shop
    )
    AND "enabled" = TRUE
ORDER BY "sales" DESC
LIMIT 4
`

type GetProductsFromNearByShopRow struct {
	ID          int32          `json:"id" param:"id"`
	Name        string         `form:"name" json:"name"`
	Description string         `form:"description" json:"description"`
	Price       pgtype.Numeric `json:"price" swaggertype:"number"`
	ImageID     string         `json:"image_id"`
	Sales       int32          `json:"sales"`
}

func (q *Queries) GetProductsFromNearByShop(ctx context.Context) ([]GetProductsFromNearByShopRow, error) {
	rows, err := q.db.Query(ctx, getProductsFromNearByShop)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductsFromNearByShopRow{}
	for rows.Next() {
		var i GetProductsFromNearByShopRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.ImageID,
			&i.Sales,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsFromPopularShop = `-- name: GetProductsFromPopularShop :many
WITH popular_shop AS (
    SELECT S."id" AS "id"
    FROM "shop" S,
        "order_history" O
    WHERE S."id" = O."shop_id"
        AND S."enabled" = TRUE
        AND O."created_at" >= (NOW() - (INTERVAL '1 month'))
        AND (
            SELECt COUNT("product"."id")
            FROM "product"
            WHERE "product"."shop_id" = S."id"
                AND "product"."enabled" = TRUE
        ) >= 1
    GROUP BY S."id"
    ORDER BY COUNT(O."id") DESC
    LIMIT 1
)
SELECT "id",
    "name",
    "description",
    "price",
    "image_id",
    "sales"
FROM "product"
WHERE "shop_id" = (
        SELECT "id"
        FROM popular_shop
    )
    AND "enabled" = TRUE
ORDER BY "sales" DESC
LIMIT 4
`

type GetProductsFromPopularShopRow struct {
	ID          int32          `json:"id" param:"id"`
	Name        string         `form:"name" json:"name"`
	Description string         `form:"description" json:"description"`
	Price       pgtype.Numeric `json:"price" swaggertype:"number"`
	ImageID     string         `json:"image_id"`
	Sales       int32          `json:"sales"`
}

func (q *Queries) GetProductsFromPopularShop(ctx context.Context) ([]GetProductsFromPopularShopRow, error) {
	rows, err := q.db.Query(ctx, getProductsFromPopularShop)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductsFromPopularShopRow{}
	for rows.Next() {
		var i GetProductsFromPopularShopRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.ImageID,
			&i.Sales,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRandomProducts = `-- name: GetRandomProducts :many
SELECT "id",
    "name",
    "description",
    "price",
    "image_id",
    "sales"
FROM "product"
WHERE "enabled" = TRUE
ORDER BY "image_id" -- random but stable
LIMIT $1 OFFSET $2
`

type GetRandomProductsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetRandomProductsRow struct {
	ID          int32          `json:"id" param:"id"`
	Name        string         `form:"name" json:"name"`
	Description string         `form:"description" json:"description"`
	Price       pgtype.Numeric `json:"price" swaggertype:"number"`
	ImageID     string         `json:"image_id"`
	Sales       int32          `json:"sales"`
}

func (q *Queries) GetRandomProducts(ctx context.Context, arg GetRandomProductsParams) ([]GetRandomProductsRow, error) {
	rows, err := q.db.Query(ctx, getRandomProducts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRandomProductsRow{}
	for rows.Next() {
		var i GetRandomProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.ImageID,
			&i.Sales,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSellerNameByShopID = `-- name: GetSellerNameByShopID :one
SELECT "seller_name"
FROM "shop"
WHERE "id" = $1
`

func (q *Queries) GetSellerNameByShopID(ctx context.Context, id int32) (string, error) {
	row := q.db.QueryRow(ctx, getSellerNameByShopID, id)
	var seller_name string
	err := row.Scan(&seller_name)
	return seller_name, err
}

const getShopCoupons = `-- name: GetShopCoupons :many
SELECT "id",
    "type",
    "scope",
    "name",
    "description",
    "discount",
    "start_date",
    "expire_date"
FROM "coupon"
WHERE "shop_id" = $1
    OR "scope" = 'global'
ORDER BY "id" ASC
LIMIT $2 OFFSET $3
`

type GetShopCouponsParams struct {
	ShopID pgtype.Int4 `json:"shop_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

type GetShopCouponsRow struct {
	ID          int32              `json:"id" param:"id"`
	Type        CouponType         `json:"type"`
	Scope       CouponScope        `json:"scope"`
	Name        string             `json:"name"`
	Description string             `json:"description"`
	Discount    pgtype.Numeric     `json:"discount" swaggertype:"number"`
	StartDate   pgtype.Timestamptz `json:"start_date" swaggertype:"string"`
	ExpireDate  pgtype.Timestamptz `json:"expire_date" swaggertype:"string"`
}

func (q *Queries) GetShopCoupons(ctx context.Context, arg GetShopCouponsParams) ([]GetShopCouponsRow, error) {
	rows, err := q.db.Query(ctx, getShopCoupons, arg.ShopID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetShopCouponsRow{}
	for rows.Next() {
		var i GetShopCouponsRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Scope,
			&i.Name,
			&i.Description,
			&i.Discount,
			&i.StartDate,
			&i.ExpireDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShopInfo = `-- name: GetShopInfo :one
SELECT "seller_name",
    "image_id",
    "name",
    "description"
FROM "shop"
WHERE "seller_name" = $1
    AND "enabled" = TRUE
`

type GetShopInfoRow struct {
	SellerName  string `json:"seller_name" param:"seller_name"`
	ImageID     string `json:"image_id" swaggertype:"string"`
	Name        string `form:"name" json:"name"`
	Description string `form:"description" json:"description"`
}

func (q *Queries) GetShopInfo(ctx context.Context, sellerName string) (GetShopInfoRow, error) {
	row := q.db.QueryRow(ctx, getShopInfo, sellerName)
	var i GetShopInfoRow
	err := row.Scan(
		&i.SellerName,
		&i.ImageID,
		&i.Name,
		&i.Description,
	)
	return i, err
}

const getShopProducts = `-- name: GetShopProducts :many
SELECT P."id",
    P."name",
    P."description",
    P."price",
    P."image_id",
    P."expire_date",
    P."stock",
    P."sales"
FROM "product" P,
    "shop" S
WHERE S."seller_name" = $1
    AND P."shop_id" = S."id"
    AND P."enabled" = TRUE
ORDER BY P."sales" DESC
LIMIT $2 OFFSET $3
`

type GetShopProductsParams struct {
	SellerName string `json:"seller_name" param:"seller_name"`
	Limit      int32  `json:"limit"`
	Offset     int32  `json:"offset"`
}

type GetShopProductsRow struct {
	ID          int32              `json:"id" param:"id"`
	Name        string             `form:"name" json:"name"`
	Description string             `form:"description" json:"description"`
	Price       pgtype.Numeric     `json:"price" swaggertype:"number"`
	ImageID     string             `json:"image_id"`
	ExpireDate  pgtype.Timestamptz `json:"expire_date" swaggertype:"string"`
	Stock       int32              `form:"stock" json:"stock"`
	Sales       int32              `json:"sales"`
}

func (q *Queries) GetShopProducts(ctx context.Context, arg GetShopProductsParams) ([]GetShopProductsRow, error) {
	rows, err := q.db.Query(ctx, getShopProducts, arg.SellerName, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetShopProductsRow{}
	for rows.Next() {
		var i GetShopProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.ImageID,
			&i.ExpireDate,
			&i.Stock,
			&i.Sales,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagInfo = `-- name: GetTagInfo :one
SELECT "id",
    "name"
FROM "tag"
WHERE "id" = $1
`

type GetTagInfoRow struct {
	ID   int32  `json:"id"`
	Name string `json:"name"`
}

func (q *Queries) GetTagInfo(ctx context.Context, id int32) (GetTagInfoRow, error) {
	row := q.db.QueryRow(ctx, getTagInfo, id)
	var i GetTagInfoRow
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const shopExists = `-- name: ShopExists :one
SELECT "id"
FROM "shop" AS s
WHERE s."seller_name" = $1
    AND s."enabled" = TRUE
`

func (q *Queries) ShopExists(ctx context.Context, sellerName string) (int32, error) {
	row := q.db.QueryRow(ctx, shopExists, sellerName)
	var id int32
	err := row.Scan(&id)
	return id, err
}
